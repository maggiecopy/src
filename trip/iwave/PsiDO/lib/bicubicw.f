	subroutine bicubic(x1in,dxin,nxin,y1in,dyin,nyin,zin,
     1      x1out,dxout,nxout,y1out,dyout,nyout,zout,iend,work,
     1	    wl,ierr)

cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c	Bicubic spline 
c	by Ann Campbell
c
c	function: this program takes data in two dimensions,
c	          and by using cubic splines, creates a new
c		  set of data in two dimensions with defined
c		  initial values, sample rates, and number of
c		  data points.
c
c	the parameters are:
c	x1in:	initial x value(first dimension) for input data
c	dxin:	sample rate for x values for input data
c	nxin:	number of x values for input data
c	y1in:	initial y value(second dimension) for input data
c	dyin:	sample rate for y values for input data
c	nyin:	number of y values for input data
c	zin:	function values for input data, is matrix of
c		size nxin by nyin
c	x1out:	initial x value(first dimension) for output data
c	dxout:	sample rate for x values for output data
c	nxout:	number of x values for output data
c	y1out:	initial y value(second dimension) for output data
c	dyout:	sample rate for y values for output data
c	nyout:	number of y values for output data
c	zout:	output matrix, of size nxout by nyout
c	iend:	type of end condition to be used
c		iend=1  linear ends
c		iend=2	parabolic ends
c		iend=3  cubic ends
c       work:   vector of workspace
c       wl:     length of work vector
c       ierr:   error flag, will equal 0 if no errors
c	g1,g2,gw: used to determine allotment of workspace
c	ptr1,ptr2,ptr3:used to set pointers in workspace, so
c		1-D programs can be used
c	a,b,c:	coefficients of spline created using y values
c	u:	current output y value
c	dy:	difference between current output y value and input
c		y value that is closest to it
c	i:	do loop counter           
c	j:	do loop counter, also used to hold intermediate values
c	int:	the interval of the input values containing a specific 
c		output y value
c	k:	used in intermediate calculations
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

	real x1in,dxin,y1in,dyin,zin(nxin,nyin)
	real x1out,dxout,y1out,dyout,zout(nxout,nyout)
	real a,b,c,u,dy
	integer wl,i,j,nxin,nyin,nxout,nyout,iend,int,k,ierr
	real work(wl) 
	integer g1,g2,gw,ptr1,ptr2,ptr3
	

c	first test to see if error flag equals 0 (no error).
c	if it does not, it should return to the calling 
c	program.
c	
	
	if (ierr.eq.0) then

c
c	now check to see that an appropriate end condition has
c	been provided
c
	if (iend.lt.1.or.iend.gt.3) then
		ierr=11
c		write(6,*)'** Error in bicubic spline program **'
c		write(6,*)'   incorrect end condition given'
c		write(6,*)'choose end condition between 1 and 3'
		return
	end if

c
c	check if there are a sufficient number of data points
c	for the program to work correctly
c
	if (nxin.lt.3.or.nyin.lt.3) then
		ierr=12
c		write(6,*)'** Error in bicubic spline program **'
c		write(6,*)'   not enough input data points'
		return
	end if

		if (nyin.ge.nxin) then 
		g1=nyin
		else
		g1=nxin
		end if
		if (nyin.ge.nxout) then
		g2=nyin
		else
		g2=nxout
		end if
		if (4*nyin-8.ge.4*nxin-3) then
		gw=4*nyin-8
		else
		gw=4*nxin-3
		end if

c
c	check to see if a sufficient amount of workspace has
c	been provided
c
	if (wl.lt.nxin*nyin+g1+g2+gw) then
		ierr=10
c		write(6,*)'**Error in bicubic spline program**'
c		write(6,*)'       not enough workspace'
c		write(6,*)
c		write(6,*)wl,' was length provided'
c		write(6,*)nxin*nyin+g1+g2+gw,' was length needed'  
		return
	end if



c
c	first, this program calculates the values of the second
c	derivatives for the input matrix, with respect to the
c	y values. These values are stored in work(g1+g2+gw+1..
c	g1+g2+gw+nxin*nyin).
c
	ptr1=1
	ptr2=1+g1
	ptr3=1+g1+g2

	do 100 i=1,nxin
		do 50 j=1,nyin
		work(j)=zin(i,j)
 50		continue
	call svalues(y1in,dyin,work(ptr1),nyin,work(ptr2),iend,
     1	             work(ptr3),gw,ierr)
		do 60 j=1,nyin
		work(i+g1+g2+gw+(j-1)*nxin)=work(j+g1)
 60		continue
 100	continue
c	
c	To use the splines generated by these second derivative
c	values, I must first determine what interval of the input
c	y values each of the output y values lies in.  For each output
c	y value, I create a vector of length nxin, stored in work(1..
c	nxin), by applying the splines created using the second 
c       derivative values to the values of the input matrix in
c	the appropriate interval.
c
	int=1
	u=y1out
	do 300 i=1,nyout
	if (u.ge.y1in+(nyin-1)*dyin) then
		int=nyin-1
		goto 150
	end if
	if (u.ge.y1in+(int-1)*dyin) then
		if (u.le.y1in+int*dyin) then
		goto 150
		end if
	end if
	int=1
	j=nyin+1
 125	k=(int+j)/2
	if (u.lt.y1in+(k-1)*dyin) then
		j=k
	else
		int=k
	end if
	if (j.gt.int+1) then
		goto 125
	else
		goto 150
	end if
 150	continue

	do 200 j=1,nxin
           a=(work(j+int*nxin+g1+g2+gw) - 
     &          work(j+(int-1)*nxin+g1+g2+gw))/(6*dyin)
           b=work(j+g1+g2+gw+(int-1)*nxin)/2
           c=((zin(j,int+1)-zin(j,int))/dyin)-
     &          ((2*dyin*work(j+g1+g2+gw+(int-1)*nxin)+dyin*
     &          work(j+int*nxin+g1+g2+gw))/6)
           dy=u-(y1in+(int-1)*dyin)
           work(j)=zin(j,int)+dy*(c+dy*(b+dy*a))
 200	continue
c
c	now I create a x-z spline using these values to  
c	transform from length nxin to the final length nxout.
c	the final values are calculated using work(g1+1..g1+nxout),
c	but are stored in the output matrix - zout.
c
	call cubic(x1in,dxin,work(ptr1),nxin,x1out,dxout,work(ptr2),     
     1      nxout,iend,work(ptr3),gw,ierr)
	do 250 j=1,nxout
	zout(j,i)=work(j+g1)
 250	continue

	u=u+dyout
 300	continue
	end if
	return
	end



